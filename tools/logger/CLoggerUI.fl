# data file for the Fltk User Interface Designer (fluid)
version 1.0110 
header_name {.h} 
code_name {.cxx}
comment {*****************************************************************************

 CLoggerUI - Data logger application user interface object.

 Copyright (c) 2011-2013 Texas Instruments Incorporated.  All rights reserved.
 Software License Agreement
 
 Texas Instruments (TI) is supplying this software for use solely and
 exclusively on TI's microcontroller products. The software is owned by
 TI and/or its suppliers, and is protected under applicable copyright
 laws. You may not combine this software with "viral" open-source
 software in order to form a larger program.
 
 THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
 NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
 NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
 CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
 DAMAGES, FOR ANY REASON WHATSOEVER.
 
 This is part of revision 10636 of the Stellaris Firmware Development Package.

 **** This file was automatically generated by FLUID from ****
 **** CLoggerUI.fl. DO NOT EDIT!                          ****

*****************************************************************************
} {in_source in_header
} 

declblock {\#ifndef __WIN32} {open after {\#endif}
} {
  decl {\#include <X11/xpm.h>} {global
  }
  decl {\#include "logger.xpm"} {global
  }
} 

Function {AddWindowIcon(Fl_Window *pWindow)} {open private return_type void
} {
  code {\#ifdef __WIN32
pWindow->icon((char *)LoadIcon(fl_display, MAKEINTRESOURCE(1)));
\#else
Pixmap p, m;

fl_open_display();

XpmCreatePixmapFromData(fl_display, DefaultRootWindow(fl_display), (char **)logger_xpm, &p, &m, NULL);

pWindow->icon((char *)p);
\#endif} {}
} 

class CLoggerUI {open
} {
  decl {std::fstream mfLogFile;} {public
  }
  decl {bool mbLogging;} {public
  }
  decl {std::string mstrLogFileName;} {}
  decl {bool mbOverwrite;} {}
  Function {CLoggerUI(int x, int y)} {open
  } {
    Fl_Window mainWindow {
      label {Stellaris Data Logger} open
      xywh {946 383 900 655} type Double hide
    } {
      Fl_Menu_Bar {} {
        label menuMain open
        xywh {0 0 900 20}
        code0 {\#include "FL/Fl_File_Chooser.H"}
      } {
        Submenu {} {
          label File open
          xywh {5 5 62 20}
        } {
          MenuItem {} {
            label {Log File...}
            callback {PrivSelectLogFile();}
            xywh {5 5 30 20}
            code0 {\#include "logger.h"}
          }
          MenuItem {} {
            label {Start Logging}
            callback {PrivStartLogging();}
            xywh {5 5 30 20} deactivate
            code0 {\#include "logger.h"}
          }
          MenuItem {} {
            label {Stop Logging}
            callback {PrivStopLogging()}
            xywh {5 5 30 20} deactivate
            code0 {\#include "logger.h"}
          }
          MenuItem {} {
            label Quit
            callback {PrivQuit()}
            xywh {5 5 30 20}
            code0 {\#include "logger.h"}
          }
        }
      }
      Fl_Group {} {open
        xywh {5 30 890 630}
      } {
        Fl_Box {} {
          xywh {25 30 850 140} box DOWN_FRAME selection_color 19 labeltype NO_LABEL
        }
        Fl_Box {} {
          xywh {25 180 850 140} box DOWN_FRAME
        }
        Fl_Box {} {
          xywh {25 330 850 140} box DOWN_FRAME
        }
        Fl_Box {} {
          xywh {25 480 850 140} box DOWN_FRAME
        }
        Fl_Light_Button mCH0Switch {
          label CH0
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the CH0 sample stream} xywh {715 46 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 4
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mCH1Switch {
          label CH1
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the CH1 sample stream} xywh {715 76 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 2
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mCH2Switch {
          label CH2
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the CH2 sample stream} xywh {715 106 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 6
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mCH3Switch {
          label CH3
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the CH3 sample stream} xywh {715 136 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 1
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mAccelXSwitch {
          label X
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the X acceleration sample stream} xywh {715 210 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 216
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mAccelYSwitch {
          label Y
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the Y acceleration sample stream} xywh {715 240 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 62
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mAccelZSwitch {
          label Z
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the Z acceleration sample stream} xywh {715 270 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 5
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mTempIntSwitch {
          label {Int.}
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the internal temperature sample stream} xywh {715 370 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 142
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mTempExtSwitch {
          label {Ext.}
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the external temperature sample stream} xywh {715 400 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 200
          code0 {\#include "logger.h"}
        }
        Fl_Light_Button mCurrentSwitch {
          label CPU
          callback {HandleButton(o, v);}
          tooltip {Toggle display of the CPU current sample stream} xywh {715 536 68 24} color 23 selection_color 61 labeltype SHADOW_LABEL labelfont 1 labelsize 16 labelcolor 3
          code0 {\#include "logger.h"}
        }
        Fl_Box mCHStripChart {
          label {ADC Channels (V)}
          xywh {35 40 670 120} box DOWN_BOX color 32 labelcolor 23
          code0 {\#include "CStripChart.h"}
          class CStripChart
        }
        Fl_Box mAccelStripChart {
          label {Accelerometer (g)}
          xywh {35 190 670 120} box DOWN_BOX color 32 labelcolor 23
          code0 {\#include "CStripChart.h"}
          class CStripChart
        }
        Fl_Box mTempStripChart {
          label {Temperature (Celsius)}
          xywh {35 340 670 120} box DOWN_BOX color 32 labelcolor 23
          code0 {\#include "CStripChart.h"}
          class CStripChart
        }
        Fl_Box mCurrentStripChart {
          label {Current (mA)}
          xywh {35 490 670 120} box DOWN_BOX color 32 labelcolor 23
          code0 {\#include "CStripChart.h"}
          class CStripChart
        }
        Fl_Output mCH0Output {
          xywh {795 46 70 24} labeltype NO_LABEL
        }
        Fl_Output mCH1Output {
          xywh {795 76 70 24} labeltype NO_LABEL
        }
        Fl_Output mCH2Output {
          xywh {795 106 70 24} labeltype NO_LABEL
        }
        Fl_Output mCH3Output {
          xywh {795 136 70 24} labeltype NO_LABEL
        }
        Fl_Output mAccelXOutput {
          xywh {795 210 70 24} labeltype NO_LABEL
        }
        Fl_Output mAccelYOutput {
          xywh {795 240 70 24} labeltype NO_LABEL
        }
        Fl_Output mAccelZOutput {
          xywh {795 270 70 24} labeltype NO_LABEL
        }
        Fl_Output mTempIntOutput {
          xywh {795 370 70 24} labeltype NO_LABEL
        }
        Fl_Output mTempExtOutput {
          xywh {795 400 70 24} labeltype NO_LABEL
        }
        Fl_Output mCurrentOutput {
          xywh {795 536 70 24} labeltype NO_LABEL
        }
        Fl_Output mStatusOutput {
          label {output:}
          tooltip {Information on the state of the virtual COM port connection to the data logger board.} xywh {5 630 600 20} labeltype NO_LABEL
        }
        Fl_Output mFileOutput {
          tooltip {The name of the file that will be written when logging is active.} xywh {690 630 120 20} labeltype NO_LABEL
        }
        Fl_Output mOverwriteOutput {
          tooltip {Indicates whether data is being logged or, if not, whether the log file will be overwritten or appended to when logging is started.} xywh {815 630 80 20} labeltype NO_LABEL
        }
        Fl_Output mCOMOutput {
          tooltip {The COM port that the data logger board was detected on.} xywh {615 630 70 20} labeltype NO_LABEL
        }
      }
    }
  }
  Function {show(void)} {return_type void
  } {
    code {mainWindow->show();} {}
  }
  Function {InitUI(void)} {open return_type void
  } {
    code {Fl_Color pColors[10] =
{
    (Fl_Color)0x0000C000,   // CH0
    FL_GREEN,               // CH1
    FL_CYAN,                // CH2
    FL_RED,                 // CH3
    (Fl_Color)0x0000FF00,   // Accel X
    (Fl_Color)0x00C00000,   // Accel Y
    FL_MAGENTA,             // Accel Z
    (Fl_Color)0xC0C00000,   // Current
    (Fl_Color)0xC0004000,   // External temp
    (Fl_Color)0x60E08000,   // Internal temp
};

//
// Set up our application's icon.
//
AddWindowIcon(this->mainWindow);

//
// Initialize a few basic member variables.
//
mbLogging = false;
mbOverwrite = false;

//
// Initialize status indicators.
//
mFileOutput->value("No file selected");
mOverwriteOutput->value("Append");
mStatusOutput->value("Searching for board...");

//
// Initialize the ADC channel strip chart.
//
mCHStripChart->SetNumChannels(4);
mCHStripChart->SetChannelVisibility(0x0F);
mCHStripChart->SetChannelColors(pColors, 4);
mCHStripChart->SetAxisStyle(FL_DOT, FL_DOT);
mCHStripChart->SetAnnotationColors(FL_DARK_GREEN, FL_DARK_GREEN,
                                    FL_DARK_GREEN);
mCHStripChart->SetAnnotation( ANNOTATION_FLAG_SHOW_X_MARKERS |
                               ANNOTATION_FLAG_SHOW_Y_MARKERS |
                               ANNOTATION_FLAG_LABEL_Y_AXIS |
                               ANNOTATION_FLAG_LINE_CHART,
                               100, 5000);
mCHStripChart->SetRange(0, 20000);
mCHStripChart->SetPrecision(3);

//
// Initialize the accelerometer strip chart.
//
mAccelStripChart->SetNumChannels(3);
mAccelStripChart->SetChannelVisibility(0x07);
mAccelStripChart->SetChannelColors(&pColors[4], 3);
mAccelStripChart->SetAxisStyle(FL_DOT, FL_DOT);
mAccelStripChart->SetAnnotationColors(FL_DARK_GREEN, FL_DARK_GREEN,
                                      FL_DARK_GREEN);
mAccelStripChart->SetAnnotation( ANNOTATION_FLAG_SHOW_X_MARKERS |
                                 ANNOTATION_FLAG_SHOW_Y_MARKERS |
                                 ANNOTATION_FLAG_LABEL_Y_AXIS |
                                 ANNOTATION_FLAG_LINE_CHART,
                                 100, 100);
mAccelStripChart->SetRange(-300, 300);
mAccelStripChart->SetPrecision(2);

//
// Initialize the temperature strip chart.
//
mTempStripChart->SetNumChannels(2);
mTempStripChart->SetChannelVisibility(0x03);
mTempStripChart->SetChannelColors(&pColors[8], 2);
mTempStripChart->SetAxisStyle(FL_DOT, FL_DOT);
mTempStripChart->SetAnnotationColors(FL_DARK_GREEN, FL_DARK_GREEN,
                                     FL_DARK_GREEN);
mTempStripChart->SetAnnotation( ANNOTATION_FLAG_SHOW_X_MARKERS |
                                ANNOTATION_FLAG_SHOW_Y_MARKERS |
                                ANNOTATION_FLAG_LABEL_Y_AXIS |
                                ANNOTATION_FLAG_LINE_CHART,
                                100, 100);
mTempStripChart->SetRange(-100, 800);
mTempStripChart->SetPrecision(1);

//
// Initialize the current strip chart.
//
mCurrentStripChart->SetNumChannels(1);
mCurrentStripChart->SetChannelVisibility(0x01);
mCurrentStripChart->SetChannelColors(&pColors[7], 1);
mCurrentStripChart->SetAxisStyle(FL_DOT, FL_DOT);
mCurrentStripChart->SetAnnotationColors(FL_DARK_GREEN, FL_DARK_GREEN,
                                        FL_DARK_GREEN);
mCurrentStripChart->SetAnnotation( ANNOTATION_FLAG_SHOW_X_MARKERS |
                                   ANNOTATION_FLAG_SHOW_Y_MARKERS |
                                   ANNOTATION_FLAG_LABEL_Y_AXIS |
                                   ANNOTATION_FLAG_LINE_CHART,
                                   100, 100);
mCurrentStripChart->SetRange(0, 600);
mCurrentStripChart->SetPrecision(1);

//
// Set all the light buttons since we enable display of all
// channels by default.
//
mCH0Switch->set();
mCH1Switch->set();
mCH2Switch->set();
mCH3Switch->set();
mAccelXSwitch->set();
mAccelYSwitch->set();
mAccelZSwitch->set();
mTempIntSwitch->set();
mTempExtSwitch->set();
mCurrentSwitch->set();

//
// Set the output fields to indicate no data available.
//
mCH0Output->value("No Data");
mCH1Output->value("No Data");
mCH2Output->value("No Data");
mCH3Output->value("No Data");
mAccelXOutput->value("No Data");
mAccelYOutput->value("No Data");
mAccelZOutput->value("No Data");
mTempIntOutput->value("No Data");
mTempExtOutput->value("No Data");
mCurrentOutput->value("No Data");

//
// Disable all the value indicators.
//
mCH0Output->deactivate();
mCH1Output->deactivate();
mCH2Output->deactivate();
mCH3Output->deactivate();
mAccelXOutput->deactivate();
mAccelYOutput->deactivate();
mAccelZOutput->deactivate();
mTempIntOutput->deactivate();
mTempExtOutput->deactivate();
mCurrentOutput->deactivate();} {}
  }
  Function {PrivSelectLogFile(void)} {open private return_type void
  } {
    comment {*****************************************************************************

 Show a dialog box allowing the user to select the file they want to store
 log data into.

*****************************************************************************} {in_source not_in_header
    }
    code {char *pcFilename;
int iRetcode = 2;

    //
    // If we are currently logging, return immediately.  This shouldn't
    // occur since we disable this menu item when logging but...
    //
    if(mbLogging)
    {
        return;
    }

    //
    // Keep trying until the user picks a file or cancels the
    // top level dialog box.
    //
    while(iRetcode == 2)
    {
        //
        // Show the file selection dialog and get an appropriate
        // filename from the user.
        //
        pcFilename = fl_file_chooser("Select log file",
                                     "*.csv", "datalog.csv");

        //
        // Did we get a filename from the user?
        //
        if(pcFilename)
        {
            //
            // Try to open the file for input just to see if it exists.
            //
            mfLogFile.open(pcFilename, std::fstream::in);
            mfLogFile.close();
            if(!mfLogFile.fail())
            {
                //
                // The file existed so prompt the user to tell us how to
                // handle the situation.
                //
                iRetcode = fl_choice("The file you picked already exists.\\n"
                                  "Do you want to append to it, overwrite\\n"
                                  "it or cancel and pick another?",
                                  "Overwrite", "Append", "Cancel");

                //
                // If "Cancel" was pressed, go back and show the dialog again.
                //
                if(iRetcode == 2)
                {
                    continue;
                }

                //
                // Remember the user's choice of overwrite or append.
                //
                mbOverwrite = (iRetcode == 0) ? true : false;
            }
            else
            {
                //
                // Clear the stream error flag.
                //
                mfLogFile.clear();
                break;
            }
        }
        else
        {
            //
            // The user cancelled the top level dialog box.
            //
            return;
        }
    }
    
    

    //
    // Remember the filename the user chose.
    //
    mstrLogFileName = pcFilename;

    //
    // Enable the "Start Logging..." menu option now that we have a file to
    // use.
    //
    menu_menuMain[MENU_INDEX_START].activate();

    UpdateOverwriteStatus(mbOverwrite ? INDEX_OVERWRITE : INDEX_APPEND);
    mFileOutput->value(fl_filename_name(pcFilename));} {}
  }
  Function {PrivStartLogging(void)} {open private return_type void
  } {
    comment {*****************************************************************************

 Start logging data to the file whose name was chosen using a previous call
 to SelectLogFile().

*****************************************************************************} {in_source not_in_header
    }
    code {//
    //
    // Open the log file.
    //
    mfLogFile.open(mstrLogFileName.data(),
                   std::fstream::out | (mbOverwrite ?
                   std::fstream::trunc : std::fstream::app));
    if(mfLogFile.fail())
    {
        fl_alert("The file %s cannot be opened! Do you have write permission?",
                 mstrLogFileName.data());
        mfLogFile.clear();
    }
    else
    {
        //
        // Remember that we are logging.
        //
        mbLogging = true;

        //
        // Enable the "Stop Logging..." menu and disable "Start Logging..."
        // and "Select Log File..."
        //
        menu_menuMain[MENU_INDEX_LOG_FILE].deactivate();
        menu_menuMain[MENU_INDEX_START].deactivate();
        menu_menuMain[MENU_INDEX_STOP].activate();
        UpdateOverwriteStatus(INDEX_LOGGING);
        
        //
        // Write the heading strings and units to the file.
        //
        mfLogFile << "Timestamp, , ";
        for(int iLoop = 0; iLoop < NUM_PACKET_CHANNELS; iLoop++)
        {
            mfLogFile << g_ChannelControls[iLoop].pcName << ", ";
        }
        mfLogFile << "\\n(S), (1/32768ths), ";
        for(int iLoop = 0; iLoop < NUM_PACKET_CHANNELS; iLoop++)
        {
            mfLogFile << "(" << g_ChannelControls[iLoop].pcUnit << "), ";
        }
        mfLogFile << "\\n";
        
   }} {selected
    }
  }
  Function {PrivStopLogging(void)} {open private return_type void
  } {
    comment {*****************************************************************************

 Stop logging data to a file.

*****************************************************************************
} {in_source not_in_header
    }
    code {//
    //
    // Close the log file.
    //
    mfLogFile.close();

    //
    // Make sure we are set up to append to this file so that if "Start Logging..." is
    // chosen again, we add the new data rather than throwing away what has already
    // been captured.
    //
    mbOverwrite = false;

    //
    // Remember that we are no longer logging.
    //
    mbLogging = false;

    //
    // Enable the "Start Logging..." and "Select Log File..." menu items
    // and disable "Stop Logging..."
    //
    menu_menuMain[MENU_INDEX_START].activate();
    menu_menuMain[MENU_INDEX_LOG_FILE].activate();
    menu_menuMain[MENU_INDEX_STOP].deactivate();

    UpdateOverwriteStatus(mbOverwrite ? INDEX_OVERWRITE : INDEX_APPEND);} {}
  }
  Function {PrivQuit(void)} {private return_type void
  } {
    comment {*****************************************************************************

 Exit the application.

*****************************************************************************
} {in_source not_in_header
    }
    code {int iRetcode;

    //
    // Are we currently logging to file?
    //
    if(mbLogging)
    {
        //
        // Yes - ask the user if they really want to quit.
        //
        iRetcode = fl_choice("You are current logging data. "
                             "Do you really want to quit?", "No", "Yes", NULL);

        //
        // Did they say "No"?
        //
        if(iRetcode == 0)
        {
            //
            // Yes - don't exit the program.
            //
            return;
        }

        //
        // If we get here, the user said "Yes" so stop logging before we
        // exit.
        //
        PrivStopLogging();
    }

    //
    // Leave the program.
    //
    exit(0);} {}
  }
} 
